#include "test_c.h"

void test_c::disp_result(const bool &pass)
{
    if (pass)
        printf("\x1b[32m[OK]\x1b[0m\n");
    else
        printf("\x1b[31m[FAIL]\x1b[0m\n");
}

// Constructor
test_c::test_c(Vtop *tb)
{
    tests_passed = 0;
    tests_failed = 0;
    cur_str_idx = 0;
    ctr_rst = 0;
    state = SETUP;
    // Initialized the test vectors
    to_ctr = 0;
    test_vect[0].key = {
        0x00010203,
        0x04050607,
        0x08090a0b,
        0x0c0d0e0f,
        0x10111213,
        0x14151617,
        0x18191a1b,
        0x1c1d1e1f};
    test_vect[0].non = {
        0x00000000,
        0x0000004a,
        0x00000000};
    test_vect[0].ini_blk_ctr = 1;
    test_vect[0].plaintext = "Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it.";
    test_vect[0].ciphertext = {
        0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69, 0x81,
        0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f, 0xae, 0x0b,
        0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd, 0x62, 0xb3, 0x57,
        0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8,
        0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a, 0x22, 0xb6, 0x5e,
        0x52, 0xbc, 0x51, 0x4d, 0x16, 0xcc, 0xf8, 0x06, 0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36,
        0x5a, 0xf9, 0x0b, 0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78, 0x5e, 0x42,
        0x87, 0x4d};
    ///////////////////////////////////////
    // RFC8439 Additional test vector #1 //
    ///////////////////////////////////////
    test_vect[1].key = {
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000};
    test_vect[1].non = {
        0x00000000,
        0x00000000,
        0x00000000};
    test_vect[1].ini_blk_ctr = 0;
    test_vect[1].plaintext.assign(64, '\0');
    test_vect[1].ciphertext = {
        0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90, 0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,
        0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a, 0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,
        0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d, 0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,
        0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c, 0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86};
    ///////////////////////////////////////
    // RFC8439 Additional test vector #2 //
    ///////////////////////////////////////
    test_vect[2].key = {
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000001};
    test_vect[2].non = {
        0x00000000,
        0x00000000,
        0x00000002};
    test_vect[2].ini_blk_ctr = 1;
    test_vect[2].plaintext = "Any submission to the IETF intended by the Contributor for publication as all or part of an IETF Internet-Draft or RFC and any statement made within the context of an IETF activity is considered an \"IETF Contribution\". Such statements include oral statements in IETF sessions, as well as written and electronic communications made at any time or place, which are addressed to";
    test_vect[2].ciphertext = {
        0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37, 0x6c, 0xa2, 0x3e, 0x82, 0x73, 0x70,
        0x41, 0x60, 0x5d, 0x9f, 0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff, 0x2c, 0x1d, 0x4b, 0x79, 0x55, 0xec,
        0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29, 0x15, 0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05,
        0x0e, 0x9e, 0x96, 0xd6, 0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca, 0x5e, 0xb6, 0x25, 0x0d,
        0x40, 0x42, 0xe0, 0x27, 0x85, 0xec, 0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0, 0x44, 0x0e,
        0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13, 0x2f, 0x42, 0x0e, 0x52, 0x79, 0x50,
        0x42, 0xbd, 0xfa, 0x77, 0x73, 0xd8, 0xa9, 0x05, 0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1, 0x41, 0x1c,
        0x68, 0x04, 0x65, 0x55, 0x2a, 0xa6, 0xc4, 0x05, 0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a,
        0xd0, 0x0f, 0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05, 0x26, 0x91, 0xca, 0x66,
        0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8, 0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9, 0x37, 0xd3, 0x25, 0x9d,
        0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39, 0xdd, 0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28,
        0xe6, 0x35, 0x55, 0x3b, 0xa7, 0x6c, 0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2, 0xe6, 0x2b,
        0x08, 0x71, 0xcd, 0xac, 0x63, 0x89, 0x39, 0xe2, 0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f,
        0xa8, 0xca, 0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf, 0x3d, 0xaa, 0x8b, 0x6c,
        0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79, 0xc9, 0x2b, 0x37, 0x20, 0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84,
        0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9, 0xfd, 0xa2, 0x36, 0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b,
        0xc3, 0x9c, 0x1e, 0x87, 0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12, 0x8c, 0xc0,
        0x8a, 0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80, 0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c, 0x41, 0x1f,
        0x58, 0x69, 0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16, 0xb9, 0xc1, 0xd3, 0x00, 0x62,
        0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc, 0xe0, 0x91, 0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6,
        0x98, 0xce, 0xd7, 0x59, 0xc3, 0xff, 0x9b, 0x64, 0x77, 0x33, 0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85,
        0x14, 0xea, 0x99, 0x82, 0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3, 0xd1, 0xab,
        0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba, 0x5b, 0x86, 0x2f, 0x37, 0x30, 0xe3, 0x7c, 0xfd,
        0xc4, 0xfd, 0x80, 0x6c, 0x22, 0xf2, 0x21};
    ///////////////////////////////////////
    // RFC8439 Additional test vector #3 //
    ///////////////////////////////////////
    test_vect[3].key = {
        0x1c9240a5,
        0xeb55d38a,
        0xf3338886,
        0x04f6b5f0,
        0x473917c1,
        0x402b8009,
        0x9dca5cbc,
        0x207075c0};
    test_vect[3].non = {
        0x00000000,
        0x00000000,
        0x00000002};
    test_vect[3].ini_blk_ctr = 42;
    test_vect[3].plaintext = "'Twas brillig, and the slithy toves\nDid gyre and gimble in the wabe:\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.";
    test_vect[3].ciphertext = {
        0x62, 0xe6, 0x34, 0x7f, 0x95, 0xed, 0x87, 0xa4, 0x5f, 0xfa, 0xe7, 0x42, 0x6f, 0x27, 0xa1, 0xdf,
        0x5f, 0xb6, 0x91, 0x10, 0x04, 0x4c, 0x0d, 0x73, 0x11, 0x8e, 0xff, 0xa9, 0x5b, 0x01, 0xe5, 0xcf,
        0x16, 0x6d, 0x3d, 0xf2, 0xd7, 0x21, 0xca, 0xf9, 0xb2, 0x1e, 0x5f, 0xb1, 0x4c, 0x61, 0x68, 0x71,
        0xfd, 0x84, 0xc5, 0x4f, 0x9d, 0x65, 0xb2, 0x83, 0x19, 0x6c, 0x7f, 0xe4, 0xf6, 0x05, 0x53, 0xeb,
        0xf3, 0x9c, 0x64, 0x02, 0xc4, 0x22, 0x34, 0xe3, 0x2a, 0x35, 0x6b, 0x3e, 0x76, 0x43, 0x12, 0xa6,
        0x1a, 0x55, 0x32, 0x05, 0x57, 0x16, 0xea, 0xd6, 0x96, 0x25, 0x68, 0xf8, 0x7d, 0x3f, 0x3f, 0x77,
        0x04, 0xc6, 0xa8, 0xd1, 0xbc, 0xd1, 0xbf, 0x4d, 0x50, 0xd6, 0x15, 0x4b, 0x6d, 0xa7, 0x31, 0xb1,
        0x87, 0xb5, 0x8d, 0xfd, 0x72, 0x8a, 0xfa, 0x36, 0x75, 0x7a, 0x79, 0x7a, 0xc1, 0x88, 0xd1};
}

test_c::~test_c()
{
    //        display_result(alu_err);
}

template <size_t N>
void test_c::display(const field_c::long_int<N> &tb_val)
{
    for (int i = 0; i < N; i++)
        printf("    %x\n", tb_val.v[i]);
}

bool test_c::run(
    Vtop *tb)
{
    switch (state)
    {
    case (SETUP):
    {
        to_ctr = 0;
        tb->rst = true;
        tb->val_i = false;
        cur_str_idx = 0;
        ctr_rst = 0;
        cur_len = 0;
        ciphertext_check.clear();
        printf("=======================================\n");
        printf("Performing ChaCha20 encryption. Test %d\n", cur_test);
        printf("=======================================\n");
        state = LOAD_PRIVATE_KEY;
        break;
    }
    // Select next operand, next long_int or exit test
    case (LOAD_PRIVATE_KEY):
    {
        printf("Loading private key: \n");
        display(test_vect[cur_test].key);
        field_c::set_int(tb->key, test_vect[cur_test].key, 8);

        printf("Loading nonce: \n");
        display(test_vect[cur_test].non);
        field_c::set_int(tb->non, test_vect[cur_test].non, 3);

        printf("Loading Initial block counter: ");
        tb->ini = test_vect[cur_test].ini_blk_ctr;
        printf("%d\n", test_vect[cur_test].ini_blk_ctr);

        printf("Test string:\n%s \n", test_vect[cur_test].plaintext.c_str());
        printf("Test string length: %zu\n", test_vect[cur_test].plaintext.length());

        state = DEASSERT_RESET;
        break;
    }
    case (DEASSERT_RESET):
    {
        if (ctr_rst++ == RESET_TICKS)
        {
            printf("Releasing reset...\n");
            tb->rst = false;
            state = GEN_POLY1305_OTK;
        }
        break;
    }
    case (GEN_POLY1305_OTK):
    {
        // todo
        state = RUN_TEST;
        break;
    }
    case (RUN_TEST):
    {
        if (to_ctr++ == TEST_TIMEOUT)
        {
            printf("Total data length: %zu bytes\n", test_vect[cur_test].plaintext.size());
            printf("Words in buffer: %zu bytes\n", ciphertext_check.size());
            printf("Current test: %d\n", cur_test);
            printf("Test timeout!\n");
            return true;
        }
        if (test_vect[cur_test].plaintext.size() == ciphertext_check.size())
        {
            state = RESULT;
            break;
        }
        // Send data to DUT byte-by byte when CTS is high
        if (tb->cts_i && cur_str_idx < test_vect[cur_test].plaintext.size())
        {
            tb->val_i = true;
            tb->dat_i = test_vect[cur_test].plaintext[cur_str_idx++];
        }
        else
            tb->val_i = false;
        //  Store ciphertext from DUT
        if (tb->val_o)
        {
            ciphertext_check.push_back(tb->dat_o);
        }
        // Rime
        // Wait till Ciphertext check vector is same size as Plaintext
        // state = RESULT;
        break;
    }
    case (RESULT):
    {
        printf("RESULT \n");
        if (test_vect[cur_test].ciphertext == ciphertext_check)
        {
            tests_passed++;
            printf("Test %d passed\n", tests_passed);
        }
        else
            tests_failed++;
        state = SETUP;
        cur_test++;
        if (cur_test == TESTS_TOTAL)
        {
            disp_result(tests_failed == 0);
            return true;
        }
        break;
    }
    }
    return false;
}
